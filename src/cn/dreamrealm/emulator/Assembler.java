package cn.dreamrealm.emulator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Assembler {

    // Matches: "label: INSTRUCTION (["")OPERAND1(]"'), (["')OPERAND2(]"')
    // GROUPS: 1 2 3 7
    String regex = "^[\\t ]*(?:([.A-Za-z]\\w*)[:])?(?:[\\t ]*([A-Za-z]{2,4})(?:[\\t ]+(\\[(\\w+((\\+|-)\\d+)?)\\]|\\\".+?\\\"|\\'.+?\\'|[.A-Za-z0-9]\\w*)(?:[\\t ]*[,][\\t ]*(\\[(\\w+((\\+|-)\\d+)?)\\]|\\\".+?\\\"|\\'.+?\\'|[.A-Za-z0-9]\\w*))?)?)?";

    // Regex group indexes
    public static final int GROUP_LABEL = 1;

    public static final int GROUP_OPCODE = 2;

    public static final int GROUP_OPERAND1 = 3;

    public static final int GROUP_OPERAND2 = 7;

    // MATCHES: "(+|-)INTEGER"
    String regexNum = "^[-+]?[0-9]+$";

    // MATCHES: "(.L)abel"
    String regexLabel = "^[.A-Za-z]\\w*$";

    // Contains the program code & data generated by the assembler
    List<Object> code = new ArrayList<Object>();

    // Contains the mapping from instructions to assembler line
    private Map<Integer, Object> mapping = new HashMap<Integer, Object>();

    // Hash map of label used to replace the labels after the assembler
    // generated the code
    private Map<String, Object> labels = new HashMap<String, Object>();

    // Hash of uppercase labels used to detect duplicates
    private Map<String, Object> normalizedLabels = new HashMap<String, Object>();

    private int parseNumber(String input) {
        if (input.substring(0, 2) == "0x") {
            return Integer.parseInt(input.substring(2), 16);
        } else if (input.substring(0, 2) == "0o") {
            return Integer.parseInt(input.substring(2), 8);
        } else if (input.substring(input.length() - 1) == "b") {
            return Integer.parseInt(input.substring(0, input.length() - 1), 2);
        } else if (input.substring(input.length() - 1) == "d") {
            return Integer.parseInt(input.substring(0, input.length() - 1), 10);
        } else if (Pattern.matches(regexNum, input)) {
            return Integer.parseInt(input, 10);
        } else {
            throw new RuntimeException("Invalid number format");
        }
    }

    private Integer parseRegister(String input) {
        input = input.toUpperCase();
        if (input == "A") {
            return 0;
        } else if (input == "B") {
            return 1;
        } else if (input == "C") {
            return 2;
        } else if (input == "D") {
            return 3;
        } else if (input == "SP") {
            return 4;
        } else {
            throw null;
        }
    }

    private Integer parseOffsetAddressing(String input) {
        input = input.toUpperCase();
        int m = 0;
        int base = 0;
        char c = input.charAt(0);
        if (c == 'A') {
            base = 0;
        } else if (c == 'B') {
            base = 1;
        } else if (c == 'C') {
            base = 2;
        } else if (c == 'D') {
            base = 3;
        } else if (input.substring(0, 2) == "SP") {
            base = 4;
        } else {
            return null;
        }
        int offset_start = 1;
        if (base == 4) {
            offset_start = 2;
        }
        if (input.charAt(offset_start) == '-') {
            m = -1;
        } else if (input.charAt(offset_start) == '+') {
            m = 1;
        } else {
            return null;
        }
        int offset = m * Integer.parseInt(input.substring(offset_start + 1), 10);
        if (offset < -16 || offset > 15)
            throw new RuntimeException("offset must be a value between -16...+15");
        if (offset < 0) {
            // two's complement representation in 5-bit
            offset = 32 + offset;
        }
        // shift offset 3 bits right and add code for register
        return offset * 8 + base;
    }

    private Map<String, Object> parseRegOrNumber(String input, String typeReg, String typeNumber) {
        Integer register = parseRegister(input);
        Map<String, Object> result = new HashMap<String, Object>();
        if (register != null) {
            result.put("type", typeReg);
            result.put("value", register);
        } else {
            String label = parseLabel(input);
            if (label != null) {
                result.put("type", typeNumber);
                result.put("value", label);
            } else {
                if (typeReg == "regaddress") {
                    register = parseOffsetAddressing(input);
                    if (register != null) {
                        result.put("type", typeReg);
                        result.put("value", register);
                    }
                } else {
                    int value = parseNumber(input);
                    if (value < 0 || value > 255) {
                        throw new RuntimeException(typeNumber + " must have a value between 0-255");
                    }
                    result.put("type", typeNumber);
                    result.put("value", value);
                }
            }
        }
        return result;
    }

    private String parseLabel(String input) {
        return Pattern.matches(regexLabel, input) ? input : null;
    }

    private Map<String, Object> getValue(String input) {
        Map<String, Object> value = new HashMap<String, Object>();
        switch (input.charAt(0)) {
        case '[': // [number] or [register]
            String address = input.substring(1, input.length() - 1);
            return parseRegOrNumber(address, "regaddress", "address");
        case '"': // "String"
            String text = input.substring(1, input.length() - 1);
            List<Integer> chars = new ArrayList<Integer>();
            for (int i = 0, l = text.length(); i < l; i++) {
                chars.add((int) text.charAt(i));
            }
            value.put("type", "numbers");
            value.put("value", chars);
            return value;
        case '\'': // 'C'
            String character = input.substring(1, input.length() - 1);
            if (character.length() > 1)
                throw new RuntimeException("Only one character is allowed. Use String instead");
            value.put("type", "number");
            value.put("value", (int) character.charAt(0));
        default: // REGISTER, NUMBER or LABEL
            return parseRegOrNumber(input, "register", "number");
        }
    }

    private void addLabel(String label) {
        String upperLabel = label.toUpperCase();
        if (normalizedLabels.containsKey(upperLabel)) {
            throw new RuntimeException("Duplicate label: " + label);
        }
        if (upperLabel == "A" || upperLabel == "B" || upperLabel == "C" || upperLabel == "D") {
            throw new RuntimeException("Label contains keyword: " + upperLabel);
        }
        labels.put(label, code.size());
        normalizedLabels.put(upperLabel, code.size());
    }

    private void checkNoExtraArg(String instr, Object arg) {
        if (arg != null) {
            throw new RuntimeException(instr + ": too many arguments");
        }
    }

    @SuppressWarnings("unchecked")
    public Map<String, Object> run(String input) {
        Map<String, Object> result = new HashMap<String, Object>();
        String[] lines = input.split("\n");
        for (int i = 0, l = lines.length; i < l; i++) {
            try {
                Pattern pattern = Pattern.compile(regex);
                Matcher match = pattern.matcher(lines[i]);
                if (match.group(GROUP_LABEL) != null || match.group(GROUP_LABEL) != null) {
                    if (match.group(GROUP_LABEL) != null) {
                        addLabel(match.group(GROUP_LABEL));
                    }
                    if (match.group(GROUP_OPCODE) != null) {
                        String instr = match.group(GROUP_OPCODE).toUpperCase();
                        Map<String, Object> p1, p2;
                        int opCode;
                        // Add mapping instr pos to line number
                        // Don't do it for DB as this is not a real instruction
                        if (instr != "DB") {
                            mapping.put(code.size(), i);
                        }
                        switch (instr) {
                        case "DB":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            if (p1.get("type") == "number")
                                code.add(p1.get("value"));
                            else if (p1.get("type") == "numbers")
                                for (int j = 0, k = ((List<Integer>) p1.get("value")).size(); j < k; j++) {
                                    code.add(((List<Integer>) p1.get("value")).get(j));
                                }
                            else
                                throw new RuntimeException("DB does not support this operand");
                            break;
                        case "HLT":
                            checkNoExtraArg("HLT", match.group(GROUP_OPERAND1));
                            opCode = Opcodes.NONE;
                            code.add(opCode);
                            break;
                        case "MOV":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.MOV_REG_TO_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.MOV_ADDRESS_TO_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.MOV_REGADDRESS_TO_REG;
                            else if (p1.get("type") == "address" && p2.get("type") == "register")
                                opCode = Opcodes.MOV_REG_TO_ADDRESS;
                            else if (p1.get("type") == "regaddress" && p2.get("type") == "register")
                                opCode = Opcodes.MOV_REG_TO_REGADDRESS;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.MOV_NUMBER_TO_REG;
                            else if (p1.get("type") == "address" && p2.get("type") == "number")
                                opCode = Opcodes.MOV_NUMBER_TO_ADDRESS;
                            else if (p1.get("type") == "regaddress" && p2.get("type") == "number")
                                opCode = Opcodes.MOV_NUMBER_TO_REGADDRESS;
                            else
                                throw new RuntimeException("MOV does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "ADD":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.ADD_REG_TO_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.ADD_REGADDRESS_TO_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.ADD_ADDRESS_TO_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.ADD_NUMBER_TO_REG;
                            else
                                throw new RuntimeException("ADD does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "SUB":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.SUB_REG_FROM_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.SUB_REGADDRESS_FROM_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.SUB_ADDRESS_FROM_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.SUB_NUMBER_FROM_REG;
                            else
                                throw new RuntimeException("SUB does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "INC":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg("INC", match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.INC_REG;
                            else
                                throw new RuntimeException("INC does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "DEC":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg("DEC", match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.DEC_REG;
                            else
                                throw new RuntimeException("DEC does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "CMP":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.CMP_REG_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.CMP_REGADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.CMP_ADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.CMP_NUMBER_WITH_REG;
                            else
                                throw new RuntimeException("CMP does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "JMP":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg("JMP", match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JMP_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JMP_ADDRESS;
                            else
                                throw new RuntimeException("JMP does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "JC":
                        case "JB":
                        case "JNAE":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JC_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JC_ADDRESS;
                            else
                                throw new RuntimeException(instr + " does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "JNC":
                        case "JNB":
                        case "JAE":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JNC_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JNC_ADDRESS;
                            else
                                throw new RuntimeException(instr + "does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "JZ":
                        case "JE":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JZ_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JZ_ADDRESS;
                            else
                                throw new RuntimeException(instr + " does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "JNZ":
                        case "JNE":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JNZ_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JNZ_ADDRESS;
                            else
                                throw new RuntimeException(instr + " does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "JA":
                        case "JNBE":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JA_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JA_ADDRESS;
                            else
                                throw new RuntimeException(instr + " does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "JNA":
                        case "JBE":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.JNA_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.JNA_ADDRESS;
                            else
                                throw new RuntimeException(instr + " does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "PUSH":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.PUSH_REG;
                            else if (p1.get("type") == "regaddress")
                                opCode = Opcodes.PUSH_REGADDRESS;
                            else if (p1.get("type") == "address")
                                opCode = Opcodes.PUSH_ADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.PUSH_NUMBER;
                            else
                                throw new RuntimeException("PUSH does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "POP":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.POP_REG;
                            else
                                throw new RuntimeException("add does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "CALL":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.CALL_REGADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.CALL_ADDRESS;
                            else
                                throw new RuntimeException("CALL does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "RET":
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND1));
                            opCode = Opcodes.RET;
                            code.add(opCode);
                            break;
                        case "MUL":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.MUL_REG;
                            else if (p1.get("type") == "regaddress")
                                opCode = Opcodes.MUL_REGADDRESS;
                            else if (p1.get("type") == "address")
                                opCode = Opcodes.MUL_ADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.MUL_NUMBER;
                            else
                                throw new RuntimeException("MULL does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "DIV":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.DIV_REG;
                            else if (p1.get("type") == "regaddress")
                                opCode = Opcodes.DIV_REGADDRESS;
                            else if (p1.get("type") == "address")
                                opCode = Opcodes.DIV_ADDRESS;
                            else if (p1.get("type") == "number")
                                opCode = Opcodes.DIV_NUMBER;
                            else
                                throw new RuntimeException("DIV does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "AND":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.AND_REG_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.AND_REGADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.AND_ADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.AND_NUMBER_WITH_REG;
                            else
                                throw new RuntimeException("AND does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "OR":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.OR_REG_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.OR_REGADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.OR_ADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.OR_NUMBER_WITH_REG;
                            else
                                throw new RuntimeException("OR does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "XOR":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.XOR_REG_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.XOR_REGADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.XOR_ADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.XOR_NUMBER_WITH_REG;
                            else
                                throw new RuntimeException("XOR does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "NOT":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            checkNoExtraArg(instr, match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register")
                                opCode = Opcodes.NOT_REG;
                            else
                                throw new RuntimeException("NOT does not support this operand");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            break;
                        case "SHL":
                        case "SAL":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.SHL_REG_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.SHL_REGADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.SHL_ADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.SHL_NUMBER_WITH_REG;
                            else
                                throw new RuntimeException(instr + " does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        case "SHR":
                        case "SAR":
                            p1 = getValue(match.group(GROUP_OPERAND1));
                            p2 = getValue(match.group(GROUP_OPERAND2));
                            if (p1.get("type") == "register" && p2.get("type") == "register")
                                opCode = Opcodes.SHR_REG_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "regaddress")
                                opCode = Opcodes.SHR_REGADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "address")
                                opCode = Opcodes.SHR_ADDRESS_WITH_REG;
                            else if (p1.get("type") == "register" && p2.get("type") == "number")
                                opCode = Opcodes.SHR_NUMBER_WITH_REG;
                            else
                                throw new RuntimeException(instr + " does not support this operands");
                            code.add(opCode);
                            code.add(p1.get("value"));
                            code.add(p2.get("value"));
                            break;
                        default:
                            throw new RuntimeException("Invalid instruction: " + match.group(GROUP_OPCODE));
                        }
                    }
                } else {
                    // Check if line starts with a comment otherwise the line
                    // contains an error and can not be parsed
                    String line = lines[i].trim();
                    if (line != "" && line.substring(0, 1) != ";") {
                        throw new RuntimeException("Syntax error");
                    }
                }
            } catch (Exception e) {
                throw e;
            }
        }
        // Replace label
        for (int i = 0, l = code.size(); i < l; i++) {
            if (!(code.get(i) instanceof Number)) {
                if (labels.containsKey(code.get(i))) {
                    code.set(i, labels.get(code.get(i).toString()));
                } else {
                    throw new RuntimeException("Undefined label: " + code.get(i));
                }
            }
        }
        result.put("code", code);
        result.put("mapping", mapping);
        result.put("labels", labels);
        return result;
    }
}
